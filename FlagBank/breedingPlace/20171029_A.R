# 기초 데이터 로딩
curWd <- getwd()	;setwd("..")
FB <- getFlagBank()	;setwd(curWd)
# 헤더 파일
source("20170917_A_H.R")
source("20171029_A_H.R")

devMode <- TRUE

pZh <- as.matrix(FB$zh)
if( devMode )
	pZh <- pZh[1:300,]

makeSpan <- 1:nrow(pZh)
creFunSet <- getCreateFunSet( pZh ,devMode )
eleSet <- getNewElementSet( creFunSet ,pZh=pZh[makeSpan,] )

tStamp <- Sys.time()
for( msIdx in makeSpan ){

	bornEleLst <- list()
	eleSet$rowSpan <- if( 1==msIdx ) integer(0) else 1:(msIdx-1)

	# 일단 현재 Zoid에 대한 element value, 즉 bornEleLst를 계산.
	#	bornEleLst는 나중에 유전 알고리즘에서의 평가자료로도 사용될 것이다.
	for( eleIdx in seq_len(length(creFunSet)) ){
		colVal <- sapply( creFunSet[[eleIdx]] ,function( p ){
						p$output( eleSet ,pZh[msIdx,] ,bornEleLst )
						# p$ioAddr[["outLst"]]
					})
		bornEleLst[[eleIdx]] <- colVal
	} # for(eleIdx)

	# 현재는 zoid history에 대한 element value생성 중 이므로
	#	bornEleLst를 eleSet에 저장.
	for( eleIdx in seq_len(length(creFunSet)) ){
		eleSet$eleLst[[eleIdx]]$mtx[msIdx,] <- bornEleLst[[eleIdx]]
	} # for(eleIdx)

} # for(msIdx)

stmpDiff <- Sys.time() - tStamp
k.FLogStr(sprintf("eleSet is made. cost:%.1f%s",stmpDiff,units(stmpDiff)),pConsole=T)

hAnaSet <- analyzeSeq( eleSet ,pDebug=T )
stmpDiff <- Sys.time() - tStamp
k.FLogStr(sprintf("eleSet is made. cost:%.1f%s",stmpDiff,units(stmpDiff)),pConsole=T)

save( hAnaSet ,file="Obj_hAnaSetDev.save" )
save( eleSet  ,file="Obj_eleSetDev.save")
save( creFunSet ,file="Obj_creFunSetDev.save" )



# -------------------------------------------------------
myObj <- load("Obj_hAnaSetDev.save")
myObj <- load("Obj_eleSetDev.save")
myObj <- load("Obj_creFunSetDev.save")


# 	참고 : ProbAnaObj는 20171029_ReadMe.txt의 "[확률 계산 구조]"" 항목 확인
#	- pProbBase : NULL	모두 똑같은 확률로 취급.
#				"mean"	평균 발생률을 기준하여 계산
#				"prob"	연속발생을 고려한 발생확률을 기준하여 계산
#				(ProbAnaObj의 probMtx 참고)
#	- pIsChanging: NULL	고려안함. 대신 pProb가 NULL이면 안됨.
#				"P"	비발생이 발생인 경우만 적용.(isChanging==1)
#				"N"	연속 발생이 불가한 경우만 적용.(isChanging==-1)
#				"A"	P,N 모두 적용.
#	- pCreFunId : c( fun$idStr ,fun$fGIdStr ) 다루는 데이터의 creFun 특성 확인용.
#	- pEleCord	: c( elementIdx ,columnIdx )
#	pProbBase="mean" ;pIsChanging="A" ;pEleCord=c(eIdx,cIdx) ;pStandardize=F ;pCreFunId=NULL	;pUseNA=F
getAnaTranslators <- function( pProbBase="mean" ,pIsChanging="A" ,pEleCord ,pStandardize=F ,pUseNA=F ,pCreFunId=NULL ){

		# trObj <- getAnaTranslators( pEleCord=c(eIdx,cIdx) )
		# trRst <- trObj$translate( eleSet ,pProbAnaObj )

	rObj <- list( probBase=pProbBase ,isChanging=pIsChanging ,standardize=pStandardize ,useNA=pUseNA )
	rObj$creFunId = pCreFunId	;if(!is.null(pCreFunId)) names(rObj$creFunId) <- c("ele","col") # getIoAddr() 참고.
	rObj$eleCord = pEleCord		;if(!is.null(pEleCord)) names(rObj$eleCord) <- c("ele","col")

	rObj$translate <- function( pEleSet ,pProbAnaObj ){

				trObj <- list( eleCord=rObj$eleCord )
				trObj$creFunId <- rObj$creFunId
				trObj$codeVal <- pEleSet$funCodeValLst[[ rObj$eleCord["ele"] ]][[ rObj$eleCord["col"] ]]
				trObj$codeValNA.idx <- pEleSet$funCodeValNAidxLst[[ rObj$eleCord["ele"] ]][[ rObj$eleCord["col"] ]]
				prob <-	if( is.null(rObj$probBase) ){	prob<-rep( 0.5,length(trObj$codeVal) )
							names(prob)<-colnames(pProbAnaObj$probMtx)
							prob
						} else pProbAnaObj$probMtx[ rObj$probBase , ]
				isChanging <- pProbAnaObj$probMtx[ "isChanging" ,]

				if( !rObj$useNA ){
					prob <- prob[ -trObj$codeValNA.idx ]
					isChanging <- isChanging[ -trObj$codeValNA.idx ]
				}

				if( rObj$standardize ){
					prob <- k.standardize( prob ,pPer=F )
				}

				if( !is.null(rObj$isChanging) ){
					if( "P"==rObj$isChanging ){
						prob[ isChanging== 1 ] = 1
					} else if( "N"==rObj$isChanging ) {
						prob[ isChanging==-1 ] = 0
					} else { # "A"
						prob[ isChanging== 1 ] = 1
						prob[ isChanging==-1 ] = 0
					}
				}

				trObj$prob <- prob
				trObj$isChanging <- isChanging

				return( trObj )
			}

	return( rObj )

} # getAnaTranslators()

